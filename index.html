<!DOCTYPE html>
<html>
    <head>
        <title>Decouverte du langage Rust</title>
        <meta charset="utf-8">
        <link rel="stylesheet" href="res/milligram.min.css">
        <link rel="stylesheet" href="res/custom.css">
    </head>
    <body>
        <textarea id="source">
name: default
layout: true
class: dark

---
class: center, middle

# Découverte du langage Rust

![Rust Logo](res/rust_logo.png)

Réalisé par _nanocryk <nanocryk+rust@pm.me>_ 

Présentation : https://nanocryk.github.io/ws-rust-bases/index.html  
Dépot GitHub : https://github.com/nanocryk/ws-rust-bases

---
template: default
layout: true

### Qu'est-ce que le Rust ?

---
## Présentation

- développé par Mozilla
- compilé
- statiquement et fortement typé
- paradigmes concurrents, fonctionnels et impératifs
- gère automatiquement l'allocation et libération de la mémoire
- n'utilise pas de garbage collector
- pas de *null pointer*, *use after free*, *double free*, ...
- pas de *data race* dans du code séquentiel comme concurrent

---
template: default
layout: true

### Installation

---
# Rustup

```
curl https://sh.rustup.rs -sSf | sh
```

- gère les toolchains (version du langage, stable/nightly, plateforme cible)
- installation de plugins du compilateur
- intègre cargo, gestionnaire de projets et de dépendances

> **Attention** : Bien s'assurer que `~/.cargo/bin` soit dans votre `PATH`.

Pour mettre à jour les toolchains :

```
rustup update
```

---
# IDE

## Visual Studo Code

-   Rust(rls) `rust-lang.rust`  
    Autocompletion, affichage des erreurs/warnings.
-   Better TOML `bungcip.better-toml`  
    Fichiers de configuration
-   crates `serayuzgur.crates`  
    Info sur les dépendances depuis le fichier de config
-   CodeLLDB `vadimcn.vscode-lldb`  
    Debugging

## IntelliJ

- Plugin Rust

---
## Quelques autres outils

### clippy

Pour avoir des suggestions de code plus idiomatique

```
rustup component add clippy
```

```
cargo clippy
```

### format

Pour suivre les conventions de style

```
rustup component add rustfmt
```

```
cargo fmt
```

---
template: default
layout: true

### Hello, world!

---
# Créer un projet

```
cargo new ws-hello-world
cd ws-hello-world
```

Le dossier contient les fichiers suivants :

```
Cargo.toml
src/
    main.rs
```

Compiler et lancer le projet :

```
cargo run
```

---
# Cargo.toml

```toml
[package]
# Nom du projet
name = "ws-hello-world"

# Version du projet
version = "0.1.0"

# Auteurs
authors = ["nanocryk <nanocryk+rust@pm.me>"]

# Edition de Rust (2018 ou 2015; 2015 si absent)
edition = "2018" 


# Liste des dépendances
[dependencies]
```

---
# main.rs

```rust
fn main() {
    println!("Hello, world!");
}
```

--
- `fn` permet de déclarer une fonction
- `main` est la fonction principale du programme
- `println!` permet d'afficher du texte
- `!` indique que l'on appelle une macro
- on ecrirait `println("Hello, world!")` si c'était une fonction

---
template: default
layout: true

### Concepts de bases

---
# Variables

Les variables sont déclarées avec le mot-clé `let` :

```rust
let ma_variable = 0;
```

De part son utilisation, Rust en déduit que c'est un nombre.

On peut donner explicitement le type de la variable :

```rust
let ma_variable: u32 = 0;
```

Les types de nombres sont :

- `u8`, `u16`, `u32`, `u64`, `u128` : nombre naturels
- `i8`, `i16`, `i32`, `i64`, `i128` : nombre entiers
- `f32`, `f64` : nombre réels
- `bool` : booléen, `true` ou `false`

---
# println!

`println!` permet d'afficher la valeur des variables.

```rust
let val = 42;
println!("La réponse est {}", 42);
```

L'affichage des données est assez personnalisable mais nécéssite des
notions plus avancées.

---
# Mutabilité

Immutable par defaut.

```rust
let ma_variable = 0;
ma_variable = 42; // erreur de compilation
```

Le mot-clé `mut` permet de rendre une variable mutable :

```rust
let mut ma_variable = 0;
ma_variable = 42;
```

---
# Conditions

```rust
if ma_variable < 100 {
    // faire quelque chose
}
```

```rust
if ma_variable < 100 {
    // faire quelque chose
} else if ma_variable < 200 {
    // ou autre chose
} else {
    // sinon ça
}
```

> Pas de `()` autour de la condition, `{}` obligatoires.

---
# Expressions

La value de la dernière expression d'un bloc (if/else, fonction, etc) est
retourné dans le bloc supérieur.


On peut par exemple ecrire ceci :

```rust
let var2 = 18 + if ma_variable < 100 {
    42
} else {
    96
};
```

---
# Boucles

```rust
while ma_variable < 100 {
    // faire quelque chose
}
```

Une boucle infinie peut s'écrire

```rust
loop {
    // faire quelque chose
}
```

- `continue;` : passe au tour de boucle suivant
- `break;` : sort de la boucle

> Note : `break valeur;` permet de retourner une valeur en dehors de la boucle.

---
# Boucles

La boucle `for` permet de parcourir des itérateurs, par exemple un interval :

```rust
for i in [0..10] {
    println!("i = {}", i);
}

// 0
// 1
// ...
// 8
// 9
```

> La valeur de droite est exlue.
> Pour quelle soit inclue, il faut écrire `[0..=10]`.


---
template: default
layout: true

### Propriétaire et emprunts

---
# Propriétée

Le concept principal de Rust !

- Chaque valeur a une variable appellée son propriétaire (owner).
- Il ne peux y avoir qu'un seul propriétaire à la fois.
- Quand le propriétaire sort de son contexte, la valeur est détruite.

> Conséquence : pas de gestion manuelle de la mémoire (`malloc`/`free`).

---
# Emprunts

Une valeur peut être empruntée sous la forme d'une référence.

Il existe 2 types de références :

- les références partagées `&` (lecture seule)
- les rérérences uniques `&mut` (lecture et écriture)

Pour une même valeur il ne peut y avoir qu'une référence unique ou plusieurs
références partagées, mais pas les 2 en même temps.

De plus, une référence ne peux pas exister plus longtemps que le propriétaire.

---
# Emprunts (exemple)

```rust
let o = {
    let val = 42;
    {
        let r = &val; // ok
        let s = &val; // ok
        let v = &mut val; // erreur : &mut et & en même temps
    } // fin du bloc, r, s et v sont détruits

    let r = &mut val; // ok
    let s = &mut val; // erreur : 2 &mut en même temps

    r
    // erreur : val va être détruit alors que l'on en retourne une
    // référence.
}
```

---
# Tableaux

Tableaux de taille statique :

```rust
let mut array: [u32; 4] = [1, 2, 3, 4];
array[1] = 42;
```

Tableaux de taille dynamique :

```rust
let mut vec: Vec<u32> = vec![1, 2, 3, 4];
vec[1] = 42;
vec.push(28);
```

Références d'un tableaux (slices) :

```rust
let vec = vec![1, 2, 3, 4, 5];
let slice: &[u32] = vec[1..3]; // [2, 3] 
```

---
# Chaîne de caractères

Les chaîne de caractères sont encodées en UTF8 (beaucoup d'alphabets, emojis, etc).

Le type principale est la "string slice" `str`, utilisée la plupart du temps sous
la forme de référence `&str`. Pour allouer une chaîne dynamiquement, on utilise
le type `String`. Une chaîne présente "en dûr" dans le code est appellée une
"string literal" et est de type `&str`.

---
# Chaîne de caractères

```rust
let hello = "Hello"; // &str
let world = ", world!" // &str
let hello = hello.to_owned() // String

// la concatenation consomme le partie de gauche et lui ajoute la
// partie de droite. La partie de gauche doit donc être une
// `String`, la droite peut être une `&str`.
let hello_world = hello + world; 

println!("{}", hello_world); // Hello, world!
```

> Note : le premier paramètre de `println!` doit obligatoirement est une
> "string literal", puisque le formattage est vérifié à la compilation. On ne 
> peut donc pas utiliser directement `hello_world`.

        </textarea>
        <script src="res/remark-latest.min.js">
        </script>
        <script>
            var slideshow = remark.create({
                highlightStyle: 'tomorrow-night',
            });
        </script>
    </body>
</html>